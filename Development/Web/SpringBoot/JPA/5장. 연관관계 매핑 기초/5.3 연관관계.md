---
title: 5.3 연관관계 
date: 2022-11-02
type:  blog
author: harris baek
email: baekjh09@naver.com
---
tags: #spring , #backend , #db, #jpa 

엄밀히 얘기하면 객체에는 양방향 연관관계라는 것이 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다. 반면, 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리한다. 이렇게 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다.

> 따라서 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 한다.
> 이것을 연관관계의 주인 이라고 한다.

---


## 5.3.1 양방향 매핑의 규칙 : 연관관계의 주인

- 연관관계의 주인만이 외래키를 관리 (등록, 수정, 삭제) 할 수 있고, 데이터베이스 연관관계와 매핑된다.
- 주인이 아닌 쪽은 읽기만 할 수 있다.

> 연관관계의 주인을 정한다는 것 = 외래 키 관리자를 선택하는것


### mappedBy 속성
주인은 mappedBy 속성을 사용하지 않는다. 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정

---

## 5.3.2 연관관계의 주인은 외래 키가 있는곳

- 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다.
- Team 엔티티는 mappedBy를 통해 주인이 아님을 설정
```java
class Team {
    @OneToMany(mappedBy = "team")  // 연관관계 주인인 Member.team
    private List<Member> members = new ArrayList<Member>();
}
```


### 중요
- 연관관계의 주인만 데이터베이스 연관관계와 매핑, 외래 키를 관리.
- 주인이 아닌 반대편은 읽기만 가능, 외래 키를 변경하지 못한다!!
- 항상 "다(N)" 쪽이 외래 키를 가진다.
- @ManyToOne은 항상 연관관계의 주인이 된다. => mappedBy 속성이 없다.


---

## 5.3.3 양방향 연관관계 저장

```java
public void testSave() {
    //팀1 저장
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    //회원1 저장
    Member member1 = new Member("member1", "회원1");
    member1.setTeam(team1);     //연관관계 설정 member1 -> team1
    em.persist(member1);

    //회원2 저장
    Member member2 = new Member("member2", "회원2");
    member2.setTeam(team1);     //연관관계 설정 member2 -> team1
    em.persist(member2);
}
```

Member.team 필드를 통해서 회원과 팀의 연관관계를 설정하고 저장하였다.


### 주인이 아닌 곳에서 입력된 값은 외래키에 영향을 주지 않는다.
```java
team1.getMembers().add(member1);        //무시
team1.getMembers().add(member2);        //무시
member1.setTeam(team1);                 //연관관계 설정(연관관계의 주인)
member2.setTeam(team1);                 //연관관계 설정(연관관계의 주인)
```

Member.team은 연관관계의 주인으로, 엔티티 매니저는 이곳에 입력된 값으로 외래 키를 관리한다. 

---

## 5.3.4 양방향 연관관계 주의점

```ad-error
양방향 연관관계 설정 후 가장 흔히 하는 실수는 연관관계의 주인엔는 값을 입력하지 않고 주인이 아닌 곳에서 값을 입력하는 것이다. 

데이터 베이스에 외래 키값이 정상적으로 저장되지 않으면 이것부터 의심해 보자
```

### 양방향 연관관계 주의점

```java
public void testSaveNonOwner() {
  //회원1 저장
  Member member1 = new Member("member1", "회원1");
  em.persist(member1);

  //회원2 저장
  Member member2 = new Member("member2", "회원2");
  em.persist(member2);
  Team team1 = new Team("team1", "팀1");

  //주인이 아닌 곳에 연관관계 설정
  team1.getMembers().add(member1);
  team2.getMembers().add(member2);
  em.persist(team1);
  }
```

### 회원을 조회한 결과
| MEMBER_ID | USERNAME | TEAM_ID |
| --------- | -------- | ------- |
| member1   | 회원1    | null    |
| member2   | 회원2    | null        |


---

## 5.3.5 순수한 객체까지 고려한 양방향 연관관계

사실 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전하다.
양쪽 방향 모두 값을 입력하지 않으면 JPA를 사용하지 않는 순수한 객체 상태에서 심각한 문제가 발생할 수 있다.

### JPA로 코드 완성

```java
public void testORM_양방향() {
  //팀1 저장
  Team team1 = new Team("team1", "팀1");
  em.persist(team1);
  Member member1 = new Member("member1", "회원1");
  // 양방향 연관관계 설정
  member1.setTeam(team1); // 연관관계 설정 member1 -> team1
  team1.getMembers().add(member1); // 연관관계 설정 team1 -> member1
  em.persist(member1);
  Member member2 = new Member("member2", "회원2");
  // 양방향 연관관계 설정
  member2.setTeam(team1); // 연관관계 설정 member2 -> team1
  team1.getMembers().add(member2); // 연관관계 설정 team1 -> member2
  em.persist(member2);
```

- Member.team : 연관관계의 주인, 이 값으로 외래 키를 관리한다.
- Team.members : 연관관계의 주인이 아니다. 따라서 저장 시에 사용되지 않느다.

> 결론: 객체의 양방향 연관관계는 양쪽 모두 관계를 맺어주자.

---

## 5.3.6 연관관계 편의 메소드

양방향 연관관계는 결국 양쪽 다 신경 써야 한다.
```java
member1.setTeam(team1); // 연관관계 설정 member1 -> team1
team1.getMembers().add(member1); // 연관관계 설정 team1 -> member1
```

이렇게 각각 호출하다 보면 실수로 둘 중 하나만 호출해서 양방향이 깨질 수 있다.
두 코드를 하나인 것처럼 사용하는 것이 안전하다. => ==연관관계 편의 메소드 : 한 번에 양방향 관계를 설정하는 메소드==

```java
public class Member {
    private Team team;
    public void setTeam(Team team) {
        this.team = team;
        team.getMembers().add(this);
    }
}
```

---

## 5.3.7 연관관계 편의 메소드 작성 시 주의사항

연관관계를 변경 시 기존의 정보를 삭제하는 코드를 추가해줘야 한다.
따라서 다음 코드가 올바른 코드이다.

```java
public class Member {
    private Team team;
    public void setTeam(Team team) {
        // 기존 팀과 관계를 제거
        if(this.team != null){
            this.team.getMembers().remove(this);
        }

        this.team = team;
        team.getMembers().add(this);
    }
}
```

