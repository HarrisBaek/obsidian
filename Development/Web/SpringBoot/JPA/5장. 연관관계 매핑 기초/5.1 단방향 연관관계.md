---
title: 5.1 단방향 연관관계
date: 2022-11-02
type:  blog
author: harris baek
email: baekjh09@naver.com
---
tags: #spring , #backend , #db, #jpa 


연관관계 중 다대일(N:1) 단방향 관계를 가장 먼저 이해해야 한다.

### 객체 연관관계와 테이블 연관관계의 가장 큰 차이
- 참조를 통한 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다.
- 객체는 참조(주소)로 연관관계를 맺는다.
ex) a.getB().getC()
- 테이블은 외래 키로 연관관계를 맺는다.
ex) A JOIN B or B JOIN A

## 5.1.1 순수한 객체 연관관계
`객체 그래프 탐색` : 참조를 사용해서 연관관계를 탐색한다.
```Java
Team findTeam = member1.getTeam();
```

## 5.1.2 테이블 연관관계
조인: 데이터 베이스는 외래 키를 사용해서 연관관계를 탐색할 수 있다.
```
SELECT T.*
FROM MEMBER M
	JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
WHERE M.MEMBER_ID ="member1"
```

## 5.1.3 객체 관계 매핑

> 회원과 팀, 다대일 관계로 가정

```java
// 매핑한 회원 엔티티
@Entity
public class Member {
    @Id
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    //연관 관계 매핑
    @ManyToOne
    @JoinColumn(name="TEAM_ID")
    private Team team;

    //연관관계 설정
    public void setTeam(Team team) {
        this.team = team;
    }
    //Getter Setter
}

// 매핑한 팀 엔티티
@Entity
public class Team {
    @Id
    @Column(name = "TEAM_ID")
    private String id;
    private String name;
    // Getter, Setter..
}
```

1. @ManyToOne
- 다대일(N:1) 관계라는 매핑 정보
- 연관관계 매핑시 이렇게 다중성을 나타내는 어노테이션을 필수로 사용

2. JoinColumn(name ="TEAM_ID")
- 조인 컬럼은 외래 키를 매핑할 때 사용
- name 속성에 매핑할 외래 키 이름을 지정
- 생략이 가능하다.

---

## 5.1.4 @JoinColumn

> 외래 키 매핑 시 사용

- 기본 적략 : 필드명_참조 테이블의 컬럼명
- ex) team_TEAM_ID

---

## 5.1.5 @ManyToOne

> 다대일 관계에서 사용

| 속성     | 기능                                              | 기본값                                                    |
| -------- | ------------------------------------------------- | --------------------------------------------------------- |
| optional | false로 설정하면 연관된 엔티티가 항상 있어야 한다 | true                                                      |
| fetch    | 글로벌 페치 전략 설정. 자세한건 8장               | @ManyToOne = FetchType.EAGER, @OneToMany = FetchType.LAZY |
| cascade  | 영속성 전이 기능 사용. 자센한건 8장               | 

---


## 5.1.6 연관관계 사용

```java
public void testSave() {

    //팀1 저장
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    //회원1 저장
    Member member1 = new Member(100L, "회원1");
    member1.setTeam(team1);     //연관관계 설정 member1 -> team1
    em.persist(member1);

    //회원2 저장
    Member member2 = new Member(101L, "회원2");
    member2.setTeam(team1);     //연관관계 설정 member2 -> team1
    em.persist(member2);
}
```

> JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.


## 5.1.7 조회

###### 엔티티를 조회하는 방법은 2가지
- 객체 그래프 탐색( 객체 연관 관계를 사용한 조회)
- 객체 지향 쿼리 사용(JPQL)

###### 객체 그래프 탐색
```java
Member member = em.find(Member.class, 100L);
Team team = member.getTeam(); // 객체 그래프 탐색 : 연관된 엔티티 조회
System.out.println("팀 이름 = " + team.getName());
```

###### 객체 지향 쿼리
```java
public static void testJPQL(EntityManager em) {
    String jpql1 = "select m from Member m join m.team t where " +
            "t.name = :teamName";
    List<Member> resultList = em.createQuery(jpql1, Member.class)
            .setParameter("teamName", "팀1")
            .getResultList();
    for (Member member : resultList) {
        System.out.println("[query] member.username = " +
                member.getUsername());
    }
}

// 결과ㅣ [query] member.username=회원1
// 결과ㅣ [query] member.username=회원2
// 실행되는 쿼리

SELECT M.* FROM MEMBER MEMBER
INNER JOIN
    TEAM TEAM ON MEMBER.TEAM_ID = TEAM1_.ID
WHERE
    TEAM1_.NAME='팀1'
```

---

## 5.1.8 수정

###### 연관 관계를 수정하는 코드
```java
private static void updateRelation(EntityManager em) {
    // 새로운 팀2
    Team team2 = new Team("team2", "팀2");
    em.persist(team2);

    //회원1에 새로운 팀2 설정
    Member member = em.find(Member.class, 100L);
    member.setTeam(team2);
}
```

> 수정은 em.update() 같은 메소드가 없다.

불러온 엔티티의 값만 변경하면 트랜잭션 커밋 시 플러시가 발생하여 변경감지 기능 작동

=> 변경사항을 데이터베이스에 자동으로 반영

---

## 5.1.9 제거

###### 연관관계를 삭제하는 코드
``` java
private static void deleteRelation(EntityManager em) {
    Member member1 = em.find(Member.class, "member1");
    member1.setTeam(null);      //연관관계 제거
}

// 실제 SQL
UPDATE MEMBER
SET
    TEAM_ID = NULL, ...
WHERE
    ID = 'member1'
```

---

## 5.1.10 연관된 엔티티 삭제


연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다.
그렇지 않으면 외래 키 제약조건으로 인해 데이터베이스에서 오류가 발생한다.

```java
member1.setTeam(null);  // 회원1 연관관계 제거
member2.setTeam(null);  // 회원2 연관관계 제거
em.remove(team);        // 팀 삭제
```
