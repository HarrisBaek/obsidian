---
title: 4.1 엔티티 매핑
date: 2022-11-02
type:  blog
author: harris baek
email: baekjh09@naver.com
---
tags: #spring , #backend , #db, #jpa

### 엔티티 매핑
대표적인 매핑 어노테이션. XML에 기입해돋 되지만 어노테이션 방식이 좀더 쉽고 직관적이다.

| 매핑               | 어노테이션      |
| ------------------ | --------------- |
| 객체와 테이블 매핑 | @Entity, @Table |
| 기본 기 매핑       | @id             |
| 필드와 컬럼 매핑   | @Column         |
| 연관관계 매핑      | @ManyToOne, @JoinColumn                |

## 4.1.1 @Entity
JPA를 사용해서 테이블과 매핑할 클래스는 @Entity를 필수로 붙여야 한다.
@Entity가 붙은 클래스는 JPA가 관리한다.

### 속성
1. name
	- JPA에서 사용할 텐티티 이름 지정. 보통 기본값인 클래스 이름을 사용한다.
	- 만약 다른 패키지에 이름이 같은 엔티티 클래스가 있다면 이름을 지정해서 충돌하지 않도록 해야한다.

### @Entity 적용 시 주의 사항
- 기본 생성자는 필수이다(파라미터가 없는 public 또는 protected 생성자)
- final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.
- 저장할 필드에 final을 사용하면 안된다.
```java
public Member() {}
public Member(String name){
	this.name = name;
}
```


```ad-warning
title: 기본 생성자 필수
자바는 생성자가 하나도 없으면 파라미터가 없는 기본 생성자를 자동으로 만들지만, 생성자가 하나 이상 존재하면 기본 생성자를 자동으로 만들지 않는다. 이때는 기본 생성자를 직접 만들어야 한다. 왜냐면 JPA가 엔티티 객체를 생성할 때는 기본 생성자를 사용하기 때문인다.
```

---

## 4.1.2 @Table
엔티티와 매핑할 테이블을 지정한다. 생략 시 매핑한 엔티티 이름을 테이블 이름으로 사용한다.
```java
@Entity
@Table(name="MEMBER")
public class Member{}
```

---

```java
import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name="MEMBER")
public class Member {
    @Id
    @Column(name = "ID")
    private String id;

    @Column(name = "NAME", nullable = false, length = 10) //추가
    private String username;
    private Integer age;
    
    @Enumerated(EnumType.STRING)
    private RoleType roleType;

    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;

    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;

    @Lob
    private String description;

    @Transient
    private String temp;
    //Getter, Setter
    ...
}

public enum RoleType {
    ADMIN, USER
}
```

## 코드 설명

**1. roleType** : 자바의 enum을 사용해서 회원 타입을 구분. 자바의 enum을 사용하려면 **@Enumerated** 어노테이션으로 매핑.

**2. createDate, lastModifiedDate** : 자바의 날짜 타입은 **@Temporal**을 사용해서 매핑

**3. description** : 회원을 설명하는 필드는 길이 제한이 없다. 데이타베이스 VARCHAR 타입 대신에 CLOB 타입으로 저장. **@Lob**를 사용하면 CLOB, BLOB 타입을 매핑할 수 있다.

## 오라클 기준 LOB 설명

-   CLOB(Character Large OBject) : 텍스트 형태 파일 크기를 4GB까지 지원
-   BLOB(Binary Large OBject) : 이진파일(이미지 등) 형태의 파일 크기를 4GB까지 지원

---

## 4.1.3 DDL 생성 기능
DDL 생성 기능으로 제약조건을 추가할 수 있다.

```java
@Entity
@Table(name="MEMBER")
public class Member{
	@id
	@Column(name="ID")
	private String id;

	@Column(name="NAME",unique=true, nullable = false, length =10) //추가
	private String username;
}

//생성된 DDL
create table MEMBER(
	ID varchar(255) not null,
	NAME varchar(10) not null,
	...
	primary key(ID)
)

```


```java
// 유니크 제약조건
@Entity(name="Member")
@Table(name="MEMBER", uniqueConstraints = {@UniqueConstraint( // 추가
    name = "NAME_AGE_UNIQUE",
    columnNames = {"NAME", "AGE"} )})
public class Member {
    @Id
    @Column(name = "ID")
    private String id;

    @Column(name = "NAME", nullable = false, length = 10) //추가
    private String username;
    ...
}

// 생성된 DDL

ALTER TABLE MEMBER
    ADD CONSTRAINT NAME_AGE_UNIQUE UNIQUE (NAME, AGE)
```

**이런 기능들은 단지 DDL을 자동으로 생성할 때만 사용되고 JPA 실행 로직에는 영향을 주지 않는다.**
따라서 스키마 자동 생성 기능을 사용하지 않고 직접 DDL을 만든다면 사용할 이유가 없다.
이 기능을 사용하면 애플리케이션 개발자가 엔티티만 보고도 손쉽게 다양한 제약조건을 파악할 수 있는 장점이 있다.



### 한개의 컬럼에 UNIQUE  설정
```java
@Column(name="column" , unique=true)
long column
```

### 두개 이상의 컬럼을 묶어 UNIQUE 설정
```java
```java
@Entity
@Table(
	name="tableName",
    uniqueConstraints={
        @UniqueConstraint(
            name={"contstraintName"}
            columnNames={"col1", "col2"}
        )
    }
)
@Data
public class Entity{
    @Column(name="col1")
    int col1;
    
    @Column(name="col2")
    int col2;
}
```
```
