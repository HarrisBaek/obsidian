
---
title: 4. 스프링 DB 접근 기술
date: 2022-10-30
type:  blog
author: harris baek
email: baekjh09@naver.com
---
tags : #spring, #backend 

### 스프링 데이터 엑세스

- H2 데이터 베이스 설치
- 순수 JDBC
- 스프링 Jdbc Template
- JPA
- 스프링 데이터 JPA
 


#### H2 데이터 베이스
- 교육용으로 간단한 H2 데이터 베이스를 설치하고 사용 세팅을 한다.
```ad-warning
title:주의!

h2 데이터베이스는 꼭 다음 링크에 들어가서 1.4.200 버전을 설치해주세요. 

최근에 나온 2.0.206 버전을 설치하면 일부 기능이 정상 동작하지 않습니다. 

https://www.h2database.com/html/download-archive.html 


만약 이미 설치하고 실행까지 했다면 다시 설치한 이후에 ~/test.mv.db 파일을 꼭 삭제해주세요. 

그렇지 않으면 다음 오류가 발생하면서 접속되지 않습니다. 

General error: "The write format 1 is smaller than the supported format 2 [2.0.206/5]" [50000-202] HY000/50000
```


##### 1. 테이블 생성하기

```sql
drop table if exists member CASCADE; 
create table member 
( 
	id bigint generated by default as identity, 
	name varchar(255), primary key (id) 
);
```

![[h2database.png]]

##### 2. 순수 JDBC 설정
- 20년도 넘은 기술이라서 별로 사용하지 않는다.
- JdbcMemberRepository를 추가하여 기존의 MemberRepository 스프링빈을 변경 시켜 준다.
- 기존 코드를 변경하지 않고 다형성을 유지하여 코드를 변경한다.

![[스크린샷 2022-10-19 오후 4.05.09.png]]

###### 스프링 통합 테스트
- 실제 스프링과 연동하여 테스트를 진행
- @SpringBootTest, @Transactional 등의 어노테이션을 사용한다.
- 스프링 부트와 함께 도는 테스트의 경우에는 시간이 오래 걸리기때문에 웬만한 연관성이 없는 비지니스 로직들은 일반 테스트로 진행 해야한다.

```ad-warning
title:@SpringBootTest
스프링 컨테이너와 테스트를 함께 실행한다.
```

```ad-warning
title: @Transactional
테스트는 반복될 수 있어야 하는데, 한번 테스트가 돌면 DB에 데이터가 들어가던지 이전의 데이터가 쌓여있게된다. @Transactional 어노테이션을 사용하면, 데이터를 넣은 다음 전부 Rollback하여 이전 상태를 유지한다.
(beforeEach, afterEach등으로 정리가 가능하지만 위가 훨씬 편리하다)
```


##### 4. JPA
- JPA가 SQL 쿼리도 JPA가 직접 만들어 준다.
- JPA가 오브젝트 중심의 설계로 패러다임을 전환을 할 수 있다.
- JPA를 사용하면 개발 생산성을 크게 높일 수 있다.
- JPA는 인터페이스이고, 구현체는 업체별로 별도로 존재한다. 그중 대표적인것이 Hibernate같은 것이다.
- show-sql : JPA가 생성하는 SQL을 출력한다
- ddl-auto:  JPA는 테이블을 자동으로 생성하는 기능을 제공하는ㄷ none를 사용하면 해당 기능을 끈다.

```gradle
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

```
```text
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.driver-class-name=org.h2.Driver  
spring.datasource.username=sa  
spring.jpa.show-sql=true  
spring.jpa.hibernate.ddl-auto=none
```

- @Entity : 테이블 하나를 나타내는 어노테이션
- @Id  : ForeignKey를 나타낸다.
- @GeneratedValue : value를 시스템에서 자동으로 만들어 준다
```java
@Entity  
public class Member {  
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    @Column(name="username")  
    private String name;  
  
    public Long getId() {  
        return id;  
    }  
  
    public void setId(Long id) {  
        this.id = id;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
}
```


```java
package com.example.hello.hellospring.repository;  
  
import com.example.hello.hellospring.domain.Member;  
import org.springframework.beans.factory.annotation.Autowired;  
  
import javax.net.ssl.SSLServerSocket;  
import javax.persistence.EntityManager;  
import java.util.List;  
import java.util.Optional;  
  
public class JpaMemberRepository implements MemberRepository{  
  
    private EntityManager em;  
  
    @Autowired  
    public JpaMemberRepository(EntityManager em) {  
        this.em = em;  
    }  
  
    @Override  
    public Member save(Member member) {  
        em.persist(member);  
        return member;  
    }  
  
    @Override  
    public Optional<Member> findById(Long id) {  
        Member member = em.find(Member.class, id);  
        return Optional.ofNullable(member);  
    }  
  
    @Override  
    public Optional<Member> findByName(String name) {  
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)  
                .setParameter("name", name)  
                .getResultList();  
  
        return result.stream().findAny();  
    }  
  
    @Override  
    public List<Member> findAll() {  
        return em.createQuery("select m from Member m", Member.class)  
                .getResultList();  
    }  
  
    @Override  
    public void clearRepository() {  
  
    }  
}
```

```ad-warning
title: @Transavtional (org.springframework.transaction.annotation.Transactional)

스프링은 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작하고, 메서드가 정상 종료되면 트랜잭션을 커밋한다. 만약 런타임 예외가 발생하면 롤백한다. 

JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다.

```

```java
@Transactional  
public class MemberService {      
    private final MemberRepository memberRepository;
```


##### 5. 스프링 데이터 JPA

- JpaRepository가 Repository Interface의 함수 이름을 바탕으로 자동으로 SQL을 생성한다.
- 특정 컬럼 이름이나 이런건 Overide형식으로 선언만 하면 알아서 찾아준다.

- 스프링 데이터 JPA 제공 
- 기능 인터페이스를 통한 기본적인 CRUD 
- findByName() , findByEmail() 처럼 메서드 이름 만으로 조회 기능 제공 
- 페이징 기능 자동 제공

```java
package com.example.hello.hellospring.repository;  
import com.example.hello.hellospring.domain.Member;  
import org.springframework.data.jpa.repository.JpaRepository;  
  
import java.util.Optional;  
  
  
/*  
* JpaRepository를 상속 받으면 자동으로 빈으로 등록이 되어, MemberRepostiory를 Autowired하면 
* 적용이 된다. 또한 함수의 이름을 바탕으로 JpaRepository가 자동으로 JPA를 생성해줌
*/
 public interface SpringDataJpaRepository extends JpaRepository<Member,Long>,MemberRepository {  
    @Override  
    public Optional<Member> findByName(String name);  
}
```

```java
package com.example.hello.hellospring.config;  
  
  
import com.example.hello.hellospring.repository.MemberRepository;  
import com.example.hello.hellospring.service.MemberService;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
  
import javax.persistence.EntityManager;  
  
@Configuration  
public class SpringConfig {  
    private EntityManager em;  
  
    private final MemberRepository memberRepository;  
  
    @Autowired  
    public SpringConfig(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
    }  
  
    @Bean  
    public MemberService memberService() {  
        return new MemberService(memberRepository);  
    }    
}

```

```ad-note
공통부가 아닌것은 findByName(String name)처럼 :Name 이름만 바꿔주면 알아서 만들어 준다.

```

>참고: 실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용하면 된다. Querydsl을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다. 이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나, 앞서 학습한 스프링 JdbcTemplate를 사용하면 된다.

##### 6. Aspect Oriented Programming

**AOP가 필요한 상황**
- 모든 메소드의 호출 시간을 측정하고 싶다면?
- 공통 관심 사항 (cross-cutting-concern)
- 회원가입시간, 회원 조회시간을 측정하고 싶다면???

>문제 회원가입, 회원 조회에 시간을 측정하는 기능은 핵심 관심 사항이 아니다. 
>시간을 측정하는 로직은 공통 관심 사항이다. 
>시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞여서 유지보수가 어렵다.
> 시간을 측정하는 로직을 별도의 공통 로직으로 만들기 매우 어렵다. 
> 시간을 측정하는 로직을 변경할 때 모든 로직을 찾아가면서 변경해야 한다.


![[스크린샷 2022-10-20 오후 9.04.04.png]]

`결국에는 코어 로직이외에 부가적인 공통 기능은 하나의 소스가 아닌 별도로 관리되는 곳에서 구현하여, 코어 기술과 공통기술을 분리하겠다라는 얘기다. 코어 로직이 실행되는 도중에 특정 시점일때 공통 로직을 실행해야 하므로 관점 지향 프로그래밍이라고 부른다.`

```java
package com.example.hello.hellospring.aop;  
  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.springframework.stereotype.Component;  
  
@Aspect  
//컴포넌트 스캔으로 등록해도 된다. 하지만 AOP를 사용한다는걸 알려줘야한다.  
// 그래서 매뉴얼로 등록 해줘야 한다.  
@Component  
public class TimeTraceAop {  
    @Around("execution(* com.example.hello.hellospring..*(..))")  
    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable{  
        long start = System.currentTimeMillis();  
//        System.out.println("START: " + joinPoint.toString());  
  
        try{  
            Object result = joinPoint.proceed();  
            return result;  
        }finally{  
            long finish = System.currentTimeMillis();  
            long timeMs = finish - start;  
            System.out.println("START: " + joinPoint.toString()+" "+timeMs+"ms");  
        }  
    }  
}
```


![[스크린샷 2022-10-20 오후 9.19.48.png]]

![[스크린샷 2022-10-20 오후 9.20.06.png]]