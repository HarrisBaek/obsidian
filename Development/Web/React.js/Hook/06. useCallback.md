---
sticker: lucide//file
---
- useMemo와 같이 캐싱기능을 가지지만, 데이터값이 아닌 Function 자체를 캐싱한다.
- useCallback된 함수는 실제로 *재렌더링시에는 무조건 캐시값을 주고*, 그 함수가 호출되면 그때 값차이를 체크해서 호출한다.

#### 잘못된 예제
- 재렌더링시에 someFunction의 ref값이 변경되기때문에 다시 그려진다.

```typescript
function App() {
  const [number, setNumber] = useState(1);

  const someFunction = ()=>{
	console.log(`someFunc:number: ${number}`)
  }

  //useeffect를 쓰게 되면, number바뀔때마다 불리게 된다.
  useEffect(()=>{
	console.log("changed someFunction");
  },[someFunction]);

  return (
    <div className="App">
      <input
        type="number"
        value={number}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setNumber(+e.target.value)}
      />
	  <br/>
	  <button onClick={someFunction}> Call someFunc</button>
    </div>
  );
}
```

#### 올바른 예제
(1) 재렌더링시, someFunction값은 usecallback이 새로 할당되서 ref값은 변경된다.
(2) 하지만 useCallback은 호출된것은 아니므로 someFunction의 내부는 실행되지 않는다.
(3)  useEffect()는 ref가 변경되었으므로 호출한다.
(4) 이후 실제로 someFunction이 호출되면 number와의 차이를 비교해서 새로 실행한다.
```typescript
function App() {
  const [number, setNumber] = useState(1);

  const someFunction = useCallback(()=>{
	console.log(`someFunc:number: ${number}`)
  },[number]);

  console.log(someFunction)
  useEffect(()=>{
	console.log("changed someFunction");
  },[someFunction]);

  return (
    <div className="App">
      <input
        type="number"
        value={number}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setNumber(+e.target.value)}
      />
	  <br/>
	  <button onClick={someFunction}> Call someFunc</button>
    </div>
  );
}
```