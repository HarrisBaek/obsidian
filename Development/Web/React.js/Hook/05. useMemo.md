
- 연산결과가 똑같은 함수의 경우useMemo를 통해 캐싱하여 성능을 향상시킴
- 컴포넌트가 계속 렌더링 될때 무거운 작업이 반복된다면, 비효율이기 때문에 useMemo를 통해 반복적으로 연산안하도록 한다.
### useEffect와 useMemo의 차이
	-> useEffect 는 Dom이후 작업에 초점, useMemo는 객체의 값을 캐싱하는것에 초첨(Optimization)


```typescript

// calculate() 함수를 초기에 실행이후, 캐싱하여 같은값 반환
// Dependancy array의 값이 변경될때는 새로 계산함
const value = useMemo(()=>{
	return calculate();
}, [item])
```



#### 예시

- 아래 무거운 작업을 실행하지 않아도, 컴포넌트가 새로 렌더링 될때는 초기화를 수행하기 때문에 실제로를 전체가 실행이 되어 느려진다.
- 아래 hardSum 부분을 useMemo를 이용하여 캐싱하여, easySum으로 인한 재렌더링시에 호출되지 않도록 해야한다.

```typescript
  

const hardCalcuate = (number: number) => {
  console.log("어려운 계산");
  for(let i =0;i<99999999;i++){}
  return number + 10000;
};

const easyCalcuate = (number: number) => {
  console.log("어려운 계산");

  return number + 1;
};
function App() {
  const [hardNumber, setHardNumber] = useState(1);
  const [easyNumber, setEasyNumber] = useState(1);

  //캐싱하여 easyNumber가 바뀔때는 호출되지 않는다.
  const hardSum = useMemo(() =>{
	return hardCalcuate(hardNumber)
  },[hardNumber]);

//   const hardSum = hardCalcuate(hardNumber);

  const easySum = easyCalcuate(easyNumber);
  return (
    <div className="App">
      <h3>어려운 계산기</h3>
      <input
        className="border"
        type="text"
        value={hardNumber}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
          setHardNumber(+e.target.value)
        }
      />
      <span>+10000 = {hardSum} </span>

      <h3>쉬운 계산기</h3>
      <input
        className="border"
        type="text"
        value={easyNumber}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
          setEasyNumber(+e.target.value)
        }
      />
      <span>+1 = {easySum} </span>
    </div>
  );
}
```
