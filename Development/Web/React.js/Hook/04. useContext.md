- 전역적으로 사용해야할 Props를 여러 컴포넌트들이 쉽게 공유하기 위해서 사용'
- Context 꼭 필요할때만 써야함 => 컴포넌트를 재사용하기 어렵다.
 
```ad-note
  ./context/ThemeContext.ts
*export const ThemeContext = createContext<T>(초기값);*

 ./App.tsx
*<ThemeContext.Provider value={{ isDark, setIsDark }}>
</ThemeContext.Provider>*

```

#### 잘못된 예시

```typescript

// 하위 컴포넌트로 isDark 와 setIsDark를 계쏙해서 전달해줘야한다.
const Footer = ({ isDark, setIsDark }: PageProps) => {
	//...
};

const Content = ({ isDark }: DarkProps) => {
	return (
	//...
};

const Header = ({ isDark }: DarkProps) => {
	return (
	//...
	)
};

const Page = ({ isDark, setIsDark }: PageProps) => {
	return (
	//...
	);
};

function App() {
	const [isDark, setIsDark] = useState(false);
	return (
		<div className="App">
			<Page isDark={isDark} setIsDark={setIsDark}></Page>
		</div>
	);
}
export default App;
```


#### useContext 사용
- createContext로 초기값 생성후, Context 태그사용하여 감싼다.
- 이후 useContext 자식 컴포넌트 어디서든 사용한다.
```typescript
  

const Footer = () => {

	const { isDark, setIsDark } = useContext<PageProps>(ThemeContext);
	
	const toggleTheme = () => {
		setIsDark(!isDark);
	};
	return (
		//...
	);
};
const Content = () => {
	const { isDark, setIsDark } = useContext<PageProps>(ThemeContext);
	return ( //...
	);
};


const Header = () => {
	const { isDark, setIsDark } = useContext<PageProps>(ThemeContext);
	return (
		//...
	);
};

type PageProps = {
isDark: boolean;
setIsDark: (isDark: boolean) => void;
};

const Page = () => {
	return (
	<div>
		<Header></Header>
		<Content></Content>
		<Footer></Footer>
	</div>
	);
};

  

function App() {
	const [isDark, setIsDark] = useState(false);
	return (
		<div className="App">
		{/* 감싸주지 않으면 초기값을 받아온다 */}
			<ThemeContext.Provider value={{ isDark, setIsDark }}>
			<Page isDark={isDark} setIsDark={setIsDark}></Page>
			</ThemeContext.Provider>
		</div>
	);
}

export default App;
```