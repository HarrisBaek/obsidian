

어떠한 컴포넌트가 *Mount, Update, Unmount* 될때 작업을 해야한다면 useEffect사용


```ad-note

1. callback 
실행 조건 : 렌더링 될때 마다 실행
useEffect(()=>{ // working....})

2. callback + dependancy array,
실행 조건 :  화면에 첫 렌더링 될대 실행 + 배열안에 값이 바뀔때 실행
useEffect(()=>{ // working....}, *[value]*)
```


### useEffect 사용 예제

```typescript
//state 바뀔때마다 계속 useEffect불리게 할수도있고, 첫번째 + State가 변경될때 할수도 있다.

function App() {
	const [count, setCount] = useState(1);
	const [name, setName] = useState("");
	const handleCountUpdate = () => {
		setCount(count + 1);
	};

	const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
		//무조건 component 새로 그림
		setName(e.target.value);
	};

	//01. 렌더링마다 매번 실행됨 - 렌더
	useEffect(() => {
		console.log("rendering");
	});
	
	//02. 첫번째 렌더링 + count가 바뀔때만 업데이트;
	useEffect(() => {
		console.log("rendering");
	},[count] );

	//03. 첫번째 렌더링 + name가 바뀔때만 업데이트
	useEffect(() => {
		console.log("rendering");
	},[name] );

	return (
	<div className="App">
		<button onClick={handleCountUpdate}>Update</button>
		<p>count:{count}</p>
		<input type="text" onChange={handleInputChange} />
		<span>name:{name}</span>
	</div>
	);
}

export default App;
```

### Clean Up 
- 컴포넌트가 Unmount 즉 종료 이후 해지해야할 것들을 콜백으로 return으로 전달
```typescript

useEffect(()=>{
	return ()=>{
			//구독 해지 콛...
		}
	}
)
```


```typescript 
const Timer = () => {
	useEffect(() => {
		const timer = setInterval(() => {
			console.log("Timer is running...");
		},1000);
	return () =>{
		clearInterval(timer);
		console.log('Timer is closed');
		}
	}, []);
	return (
		<div>
			<span>타이머를 시작합니다. 콘솔을 보세요</span>
		</div>
	);
};


function App() {
	const [showTimer, setShowTimer] = useState(false);
	return (
		<div className="App">
			{showTimer && <Timer />}
			<button onClick={()=>setShowTimer(!showTimer)}>Toggle Timer</button>
		</div>
	);
}

export default App;
```