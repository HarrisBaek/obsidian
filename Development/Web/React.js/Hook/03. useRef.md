
- ref는 컴포넌트가 unmount될때까지 값이 계속 유지된다. (변수는 컴포넌트 리렌더링시 초기화됨)
- 첫번째 용도는 저장용도로 사용한다 (*re-rendering 되더라도 값이 유지된다* + 렌더링 되지 않는다.)
- DOM에 직접 접근이 가능한다.
- 
```ad-note

*const ref= useRef(value);*
=> {current : value} // const ref
```


#### useRef 예제 (1)
```typescript
function App() {
	const [count, setCount] = useState(0);
	const countRef = useRef(0);
	console.log(countRef)
	
	const increaseCountState = () => {
		setCount(count + 1);
	};
	
	const increaseCountRef = () => {
		countRef.current = countRef.current+1;
	};
	return <div className="App">
		<p>State: {count}</p>
		<p>Ref: {countRef.current}</p>
		<button onClick = {increaseCountState}>state Up</button>
		<br />
		<button onClick = {increaseCountRef}>ref Up</button>
	</div>;
}
export default App;
```

#### useRef 예제 (2)
- 렌더링 카운트 측정
```typescript

function App() {
	const [count, setCount] = useState(1);
	const renderCount = useRef(1);
	
	useEffect(()=>{
		renderCount.current = renderCount.current+1;
		console.log('렌더링 수', renderCount.current);
	})
	
	return (
	<div className="App">
		<p>Count: {count}</p>
		<button
			onClick={() => {
			setCount(count + 1);
			}}>	
			올려
		</button>
	</div>
	);
}
export default App;

```


#### useRef를 이용한 DOM에 직접 접근
- DOM에 직접 접근해서 input 화면에 바로 포커스 되도록 하는 예제

```typescript
  
function App() {
	// 받을 DOM에 맞춰서 Type 변경 필요
	const inputRef = useRef<HTMLInputElement>(null);
	
	useEffect(() => {
		console.log(inputRef);
		if(inputRef.current != null){
			inputRef.current.focus();
		}
	}, []);
	return (
	<div className="App">
		<input ref={inputRef} className="border p-3" type="text" placeholder="username" />
		<button className="border p-3">Login</button>
	</div>
	);
}
export default App;
```