
- 리액트에서 제공하는 고차 컴포넌트이다.
- Props의 변화가 있으면 렌더링하고, 없으면 렌더링 하지 않는다.(오직 Props에만 의존, state변경되면 렌더링됨)
- *너무 많이쓰면 성능에 오히려 안좋다.*
- 원시타입이 아닌 Object나 함수의 경우에는 Reference의 주소가 변경되어 다시 그리게 되어, Memo만 쓰면 안되고, useMemo를 같이 써야한다.

![[스크린샷 2024-02-05 오후 8.59.36.png]]

![[스크린샷 2024-02-05 오후 9.00.49.png]]


```ad-note
title: React.Memo를 써야할때
1) 컴포넌트가 같은 Props로 자주 렌더링 될때
2) 컴포넌트가 렌더링 될때마다 복잡한 로직을 처리할때
```


#### 사용예제
- 자식 컴포넌트가 변경이 없지만, 부모가 리렌더링되면서 다시한번 그려져 성능적 열세
- React.Memo로 감싼 컴포넌트를 보내주면 Props가 바뀌지 않는한 그려짐


```typescript

// child.tsx
type ChildProps = {
  name: string;
  age: number;
};
const Child = ({ name, age }: ChildProps) => {
  console.count("child");
  console.log("parent component rendering");
  return (
    <div className="border-2 p-10">
      <h3>Child</h3>
      <p>name: {name}</p>
      <p>age: {age}</p>
    </div>
  );
};

//export default Child;
export default memo(Child);


//App.tsx
function App() {
  const [parentAge, setParentAge] = useState(0);
  const [childAge, setChildAge] = useState(0);

  const incrementParentAge = () => {
    setParentAge(parentAge + 1);
  };

  const incrementChildAge = () => {
    setChildAge(childAge + 1);
  };

  console.count("parent");
  console.log("parent component rendering");

  return (
    <div className="App">
      <div className="border-2 p-10">
        <h1>Parent</h1>
        <p>age: {parentAge}</p>
        <button onClick={incrementParentAge}>부모 나이 증가</button>
        <button onClick={incrementChildAge}>자녀 나이 증가</button>
        <Child name={"hong"} age={childAge} />
      </div>
    </div>
  );
}

```





