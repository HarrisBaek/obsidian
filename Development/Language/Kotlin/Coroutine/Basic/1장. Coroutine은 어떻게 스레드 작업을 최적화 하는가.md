---
title: 1. Coroutine은 어떻게 스레드 작업을 최적화 하는가
date: 2022-11-11
type:  blog
author: harris baek
email: baekjh09@naver.com
---
tags: #kotlin, #language, #concurrent, #coroutine, #process, #thread 

## 1.1 Thread 구조와 다중 Thread 작업의 필요성
하나의 프로세스(Process)에는 여러 스레드 가 있고, 각 스레드는 독립적으로 작업을 수행 할 수 있다. 예를 들어 JVM 프로세스 상에서는 스레드는 그림1과 같이 구성된다.

![[thread_struct.png]]

위 그림의 메인 스레드를 보자. JVM프로세스는 Main Thread가 종료 되면 강제로 종료되며, JVM 프로세스에 속한 Thread들도 함께 강제 종료된다. 그런데 메인 스레드말고 다른 2개의 스레드가 보인다. 이 스레드들에서는 메인 스레드와 마찬가지로 작업을 수행 할 수 있으며, 이 Thread들은 종료 되더라도 다른 Thread에 영향을 미치지 않는다. 

안드로이드 앱을 예제로 들면 Main Thread는 가장 중요한 Thread로 이 Thread는 UI를 그려주고 사용자가 화면을 눌렀을 때 이벤트를 전달받는 스레드이다. 사용자와의 인터렉션을 담당하는 Thread이다. 만약 이 Thread가 높은 부하를 받는 작업에 의해 블로킹된다면 안드로이드 앱은 멈춤 현상이 생기고, 일정 시간 이상 블로킹될 때 앱은 강제로 종료된다. 따라서 Main Thread에서 많은 부하를 받는 작업은 지양해야 하며, 다른 Thread를 생성해 해당 Thread에 높은 부하를 주는 작업을 수행하도록 만들어야 한다.

## 1.2 기존의 접근 방식과 한계점
 이러한 문제를 해결하기 위해 많은 방법이 시도되었다. 가장 대표적인 방법으로는 다음의 방식들이 있다.

```kotlin
//  Runnable 인터페이스를 구현 하는 클래스를 만든 다음 Thread에 해당 클래스를 넣어 start시키는 방식. 아래 코드에서는 전체 5개의 스레드 중 0번과 1번이 사용되었다.

fun main() {  
    val exampleRunnable = ExampleRunnable()  
  
    Thread(exampleRunnable).start()  
    Thread(exampleRunnable).start()  
    /*  
    출력    
    Runnable Running    
    Runnable Running    
    Thread[Thread-0,5,main]    
    Thread[Thread-1,5,main]    
    */
}  
  
class ExampleRunnable : Runnable {  
    override fun run() {  
        println("Runnable Running")  
        println(Thread.currentThread())  
    }  
}
```

```kotlin
//  ExecuterService를 이용해 Thread Pool을 구성하여 작업을 던지는 방식

fun main() {  
    val executerService = Executors.newFixedThreadPool(4);  
  
    executerService.submit(ExampleRunnable())  
    executerService.submit(ExampleRunnable())  
  
    /*  
    출력    
    Runnable Running    
    Runnable Running    
    Thread[Thread-0,5,main]    
    Thread[Thread-1,5,main]    
    */
}  
  
class ExampleRunnable : Runnable {  
    override fun run() {  
        println("Runnable Running")  
        println(Thread.currentThread())  
    }  
}
```

위와 같은 기존 접근 방식들의 한계점은 작업의 단위가 Thread라는 점이다. 다른 Thread로 작업을 넘기면 된다고 했는데 작업의 단위가 Thread인 것이 문제라니 도대체 무슨 말인가 싶을 것이다.

 Thread는 생성 비용이 비싸고 작업을 전환하는 비용이 비싸다. 또한 한 Thread가 다른 Thread부터의 작업을 기다려야 할 때 Blocking 되게 되면 해당 Thread는 하는 작업 없이 다른 작업이 끝마쳐질 때까지 기다려야 하기 때문에 자원은 낭비된다. 위의 작업 단위가 Thread일 경우 생기는 고질적인 문제점이다. 

구체적인 사례를 아래 그림3에서 살펴보자.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FRdSa6%2Fbtrcj1HwVAk%2FQJQBp5yo846NMG46l1QKE1%2Fimg.png)

위의 그림3을 보면 Thread1에서 작업1 수행 도중 Thread2의 작업2의 결과물이 작업1을 수행하는데 필요해졌다. 그때 Thread1은 아무것도 하는일 없이 Blocking되며 Thread2로부터 결과를 전달받아 작업1을 재개하기 까지 많은 시간이 소요된다. 이렇게 짧은 시간동안만 Blocking되면 다행이지만, 실제 상황에서는 Thread의 성능을 반도 발휘하지 못하게 만드는 Blocking이 반복될 수 있다.


### 그렇다면 코루틴은 기존 한계점을 어떻게 극복하는가?
물론 코루틴에서도 Thread라는 작업의 단위를 사용하지만, Thread 내부에서 작은 Thread 처럼 동작하는 코루틴이 존재한다. Thread하나를 일시중단 가능한 다중 경량 Thread 처럼 활용하는 것이 바로 Coroutine 이다. 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbYZ9Yw%2FbtrcuscPp8O%2FWCDBODeVEg9vPGyAO9idFk%2Fimg.png)

도대체 경량 Thread가 무엇인가? 일시 중단 가능한 것이 무엇인가? 
위 상황을 코루틴을 이요해서 해결해 보자 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbb8aKc%2FbtrcurSx6P4%2FAVKfZ4ySnWkpfBYKFPhrk1%2Fimg.png)
 
1. Thread1에서 Coroutine2개를 생성한다. Thread1의 Coroutine1에서는 작업1을 그대로 수행하게 만들고 Thread2에서는 작업2를 수행하게 만든다.  이때 마찬가지로 Thread1의 Coroutine1에서 작업1 수행 도중 Thread2로부터 결과가 필요해진다. 하지만 Thread2의 작업2가 끝나지 않아 작업1을 마저 할 수 없다.

2. 이때 **Coroutine1은 Thread1을 Blocking하는 대신 자신의 작업을 일시중단하고 Coroutine2에 Thread1 리소스 사용 권한을 넘겨준다**. 이제 Thread1의 Coroutine2가 작업3을 위해 Thread1을 사용한다. 

3. 이후 Thread2의 작업이 종료되고, 작업3을 수행하던 Coroutine2가 자신의 작업을 마무리하고 Coroutine2 자신을 일시중단 시킨다. 이제 다시 Thread1의 제어권한이 Coroutine1로 돌아왔다. Thread1은 Coroutine1이 마저 작업을 수행할 수 있도록 Thread2로부터 결과를 전달받아 작업1을 재개한다.

Blocking되는 상황이 줄어 Thread1의 Thread의 리소스를 최대한 활용할 수 있게 되었다.

**또한 Thread는 만드는 비용이 큰데,  Coroutine은 Thread를 만드는 대신 하나의 Thread 상에서 자신을 일시 중지할 수 있도록 하여 Thread 생성 비용을 줄인다.**

```ad-note
title: 코루틴이란?
코루틴은 스레드 안에서 실행되는 ==일시 중단 가능한 작업의 단위==

하나의 스레드에 여러 코루틴이 존재 할 수 있다.
```
