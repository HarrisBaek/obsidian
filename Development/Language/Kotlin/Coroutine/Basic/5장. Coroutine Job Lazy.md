---
title: 5장. Coroutine Job Lazy
date: 2022-11-11
type:  blog
author: harris baek
email: baekjh09@naver.com
---
tags: #kotlin, #language, #concurrent, #coroutine 

### Job의 생성
코루틴 빌더인 launch 메소드를 별도의 옵션 없이 사용하면 생선된 비동기 작업은 생성 후 에 바로 실행된다~!
```kotlin
val job = CoroutineScope(Dispatchers.Main).launch{ println(1) }
```

예를 들어 위와 같이 Job을 생성할 경우 이 Job은 생성과 동시에 실행된다. 이러한 방식으로 Job을 생성하면 필요한 위치에 바로 생성해서 실행시켜야 하기 때문에 코루틴 실행의 유연성이 떨어질 수 밖에 없다.

이를 해결하기 위해 Job을 생성한 후 필요할 때 수행하도록 하는 옵션이 있다.

### Job을 Lazy하게 실행하기
job을 생성한 후 바로 실행되는 것을 막기 위해서는 아래와 같이 job을 생성하는 launch 메서드에 CoroutineStart.LAZY 인자를 넘겨야 한다. 

```kotlin
val job = CoroutineScope(Dispatchers.Main).launch(start = CoroutineStart.LAZY) {  
    println(1)  
}  
// 아무것도 출력되지 않음
```

위와 같이 job이 생성되면 해당 Job은 수행되지 않고 대기 상태로 있는다. 우리는 이것을 Job이 Lazy하게 실행 된다고 한다.  이제 Lazy하게 실행되도록 생성된 Job을 실행하는 방법을 알아보자.

#### Lazy하게 생성된 Job을 실행하는 두가지 방법 : start(), join()
Lazy하게 생성된 Job은 두가지 방법으로 실행 가능하다. 바로 start() 메서드와 join() 메서드 이다.

#### start() : 일시 중단 없이 실행되는 메서드

먼저 start()를 살펴보자. start()는 생성된 코루틴 작업(Job)을 일시 중단 없이 실행한다. 따라서 실행되는 위치를 코루틴 내부나 suspend fun 내부로 바꾸는 것이 필요하지 않다. 

하지만 우리는 여기서 start()와 join()의 중요한 차이점을 인식하기 위해 main 함수를 suspend fun으로 설정한 후 테스트를 한다. 실제 실행을 위해서는 아래 코드에서 suspend가 없어도 무방하다.

```kotlin
suspend fun main() {  
	val job = CoroutineScope(Dispatchers.IO).launch(start = CoroutineStart.LAZY) 
	{  
        println("가나다")  
    }  
    job.start()  
}
```


#### join()

join 메서드는 Job가 종료될때까지 Job이 실행되고 있는 코루틴을 일시중단 해준다. 예를 들어 아래의 코드를 보자.

```kotlin
suspend fun main() {  
    val job = CoroutineScope(Dispatchers.IO).launch(start = CoroutineStart.LAZY) 
	{  
        println("가나다")  
    }  
    job.join()  
}
```

위에서 job.start()를 했을 때는 아무것도 출력되지 않았지만, join을 사용하면 <그림3>과 같이 출력된다. 이유는 Main Thread가 IO Thread의 Coroutine이 끝날 때까지 일시중단한다음 다시 진행되기 때문이다.

따라서 join()은 일시중단이 가능한 코루틴 내부나 suspend fun 내부에서 사용되어야 한다. 그렇지 않다면 <그림4>와 같은 오류가 생긴다.