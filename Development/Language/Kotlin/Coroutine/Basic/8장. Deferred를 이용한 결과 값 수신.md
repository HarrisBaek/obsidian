### Deferred란
Deferred는 직역하면 연기라는 뜻을 가진다. "결과값 수신을 연기한다"라는 뜻인데, 이는 미래의 어느 시점에 결과값이 올 것을 뜻한다.

Deferred는 `결과값을 수신하는 비동기 작업` 이라고 정의될 수 있다.


### Deferred는 Job이다.
```kotlin
public interface Deferred<out T> : Job {  
    public suspend fun await(): T  
    public val onAwait: SelectClause1<T>  
    ..}
```

async블록의 마지막줄의 값이 Deferred로 Wrapping되며(위에서는 Deferred< Int >) 이 값이 바로 Deferred의 결과값이 된다. 자 이제 결과값을 어떻게 수신받는지 알아보자.

### Deferred의 결과값 수신: await()
Deferred에서 결과값을 수신하기 위해서는 Deferred인터페이스 상의 await() 메서드를 이용한다.

Deferred에서 결과값을 수신하기 위해서는 Deferred인터페이스 상의 await()메서드를 이용한다.

예를 들어 아래와 같이 "Deferred Result"라는 String을 수신할 것으로 예상되는 Deferred가 있다고 해보자. 코드 상에서 await()을 호출하면 main() 함수가 수행되는 코루틴은 IO Thread로부터 Deferred의 결과가 수신될 때까지 일시중단된다.

```kotlin
suspend fun main() {  
    coroutineScope {  
        val deferred: Deferred<String> = async {  
            "Deferred Result"  
        }  
        val deferredResult = deferred.await() // deferred에서 결과가 올 때까지 일시중단  
        println(deferredResult)  
    }  
}
```

따라서 별도의 delay()가 없더라도 Main Thread가 IO Thread로부터 결과값을 수신 받을 때까지 일시중단되기 때문에 Main Thread가 먼저 종료될 일은 없다. 위 코드를 수행하면 아래 <그림1>과 같은 결과값이 출력된다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcmsjU5%2FbtrcOeyZOJJ%2FOnoHwVVOMyKVOPZSKEBzK0%2Fimg.png)


### Deferred가 Job과 다른점
Deferred가 Job과 다른 점이 있따면, 예외가 자동으로 전파되는 Job과는 달리 deferred는 예외를 자동으로 전파하지 않는다는 점이다. 이는 Deferred가 결과값 수신을 대기해야 하기 때문이다. Deferred는 결과값 수신을 대기하고 예외를 전파하기 위해 특수한 메서드를 사용하는 그것이 바로 위에서 다룬 Deferred인터페이스 상의 결과값 수신 메서드인 await() 이다.

아래의 코드를 보자. 아래의 코드에서 async로 만들어진 deferred는 IllegalArgumentException()을 발생시킬 것으로 예상된다.

```kotlin
suspend fun main() {  
    val exceptionHandler = CoroutineExceptionHandler { _, exception ->  
        when(exception){  
            is IllegalArgumentException -> println("More Arguement Needed To Process Job")  
            is InterruptedException -> println("Job Interrupted")  
        }  
    }  
  
    val deferred = CoroutineScope(Dispatchers.IO).async(exceptionHandler) { // root coroutine, running in GlobalScope  
        throw IllegalArgumentException()  
        arrayOf(1,2,3)  
    }  
  
    delay(1000)  
}
```

하지만 위의 코드를 실행하면 아무런 코드도 결과창에 인쇄되지 않는다. 이유는 Deferred가 자동으로 애러를 전파하지 않기 때문이다. Deferred는 미래의 어느 시점에 값을 받는 변수인데, 해당 값이 필요 없는 상황에서 애러를 전파시킬 필요가 없기 때문이다.

아래와 코드와 같이 await()을 마지막 부분에 추가해주어 Deferred로부터 결과값을 수신받을 수 있도록 하면 애러를 발생시키도록 만들수 있다.

```kotlin
suspend fun main() {  
    val exceptionHandler = CoroutineExceptionHandler { _, exception ->  
        when(exception){  
            is IllegalArgumentException -> println("More Argument Needed To Process Job")  
            is InterruptedException -> println("Job Interrupted")  
        }  
    }  
  
    val deferred = CoroutineScope(Dispatchers.IO).async(exceptionHandler) {  
        throw IllegalArgumentException()  
        arrayOf(1,2,3)  
    }  
  
    deferred.await()  
}
```

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbw2wXV%2FbtrcNLDNWEU%2FT7ttQt4ah7ojCTyOLhyY10%2Fimg.png)

하지만, 위의 코드에도 여전히 문제점이 있다. 바로 ExceptionHandler에서 애러를 처리하는 것이 아닌 Main Thread에 애러가 전파되어 Main Thread가 애러로 인해 강제종료되어 버린다. 이로 인해 IllegalArgumentException이 발생했을 때 "More Argument Needed To Process Job" 메세지가 나오지 않는다.

### Deferred의 Exception Handling
그러면 CoroutineExceptionHandler을 동작하게 만들려면 어떻게 바꿔야 할까?

바로 애러를 전파받는 위치에 CoroutineExceptionHandler을 추가해주는 것이다. 즉, async에는 별도의 CoroutineExceptionHandler 없이 전파 받는 위치에 CoroutineExceptionHandler을 추가해주면 된다.

```kotlin
suspend fun main() {  
    val exceptionHandler = CoroutineExceptionHandler { _, exception ->  
        when (exception) {  
            is IllegalArgumentException -> println("More Arguement Needed To Process Job")  
            is InterruptedException -> println("Job Interrupted")  
        }  
    }  
  
    val deferred =  
        CoroutineScope(Dispatchers.IO).async {  
            throw IllegalArgumentException()  
            arrayOf(1, 2, 3)  
        }  
  
    CoroutineScope(Dispatchers.IO).launch(exceptionHandler) { 
    // Deferred로부터 애러를 전파받는 위치  
        deferred.await()  
    }.join()  
}
```

 위의 코드의 맨 마지막 블록을 보자. 새로운 CoroutineScope을 생성하고 IO Thread 위에 exceptionHandler을 설정한 후 deferred의 결과값 수신을 해당 블록 내부에서 함으로써 Exception이 처리될 수 있게 하였다. join()을 사용한 이유는 Main Thread가 새롭게 생성된 CoroutineScope에서 생성된 작업들이 끝날때까지 종료되지 않도록 하기 위해서이다.


