---
title: 1장. 반응형 프로그래밍 이해하기
date: 2022-11-11
type:  blog
author: harris baek
email: baekjh09@naver.com
---
tags: #kotlin, #language, #concurrent, #coroutine , #flow


## 6.1 Flow의 Flattening Operator
flow는 데이터 파이프라인이다. 코드 상에서 데이터 파이프라인은 그 자체로 사요되는 경우는 거의 없으며 보통 다른 데이터 파이프라인들과 합쳐져 하나의 데이터 파이프라인을 완성한다. flow또한 여러 flow가 합쳐져 하나의 flow로 만들어 지기 위한 연산자를 제공하는데 데이터 파이프라인을 합치는 (Flatten) 연산자여서 Flattening Operator라 한다.

## 6.2 flatMapConcat
flatMapConcat은 여러 flow를 연결하는(concatenating)연산자 이다. 이름에서 알 수 있듯이 flatMapConcat은 flow를 연결해 새로운 flow를 만드는 역할을 한다. flow 간에 연결이 필요할 경우 flatMapConcat을 이요해 연결을 하면 된다.


### flatMapConcat 내부 살펴보기
```kotlin
public fun <T.R> Flow<T>.flatMapConcat(transform: suspend (value: T)->Flow<R>):Flow<R> = map(transform).flattenConcat()
```

flatMapConcat은 내부에서 두 개의 과정을 통해 flow를 flatten(합치기)한다. 

1. transform 람다식(변수)을 받아 transform 변수에 대한 map을 수행해 flow에서 발행된 데이터를 flow로 변환한다. 이 단계에서는 flow에서 발행되는 각 데이터가 flow로 변환되어 여러개의 flow가 생성된다.

2. 1에서 생성된 flow들이 flattenConcat()을 통해 합쳐져 하나의 flow가 된다.

즉, flatmapConcat은 데이터를 변환하여 flow들을 새로 생성한 후 생성된 flow들을 합쳐 하나의 flow를 만들어 낸다.

### flatMapConcat사용 예시
예를 들어 다음과 같은 flow가 있다고 해보자. 이 flow는 단순히 1과 5를 emit하는 flow이다.
``` kotlin
val flow = flow<Int>{
	emit(1)
	emit(5)
}
```

만약 이 flow에서 발행하는 값에 대해 +1, +2, +3을 된 값을 생성하는 flow가 있다고 해보자. 우리는 flow에서 발행하는 값을 받아 새로운 flow를 만들어야 하고, 새로운 flow에서 발행되는 값은 +1, +2,+3이 수행된 값이다. 즉 1에 대해서는 2,3,4가 발행되는 flow가 생성되고 5에 대해서는 6,7,8이 발행되는 flow가 생성되어야 한다. 마지막으로 새로 생성된 2개의 flow는 하나의 flow로 합쳐져야 한다.

우리는 이를 위해 flatMapConcat을 다음과 같이 사용할 수 있다.
1. CoroutineScope내에서 flatMapConcat 수행
2. flow로부터 emit 되는 데이터를 다시 flow에서 받아서 emit 하기

```kotlin
fun collectWithFlatMapConcat(){
	viewModelScope.launch{
		flow.flatMapConcat{
			intValue =>
			flow{
				emit(intValue+1)
				emit(intValue+2)
				emit(intValue+3)			
			}
		}.collect{
			println("printed value >>$it")
		}
	}
}
```


###  flatMapConcat의 한계점
flatMapConcat은 원 flow에서 발행된 데이터가 순차적으로 처리되어 새로운 flow를 만들어낸다. 이 말은 데이터 처리하는데 오래 걸리는 연산이 변환 값으로 들어올 경우 데이터가 처리되는데 오래 걸릴 것임을 뜻한다. 예를 들어 아래처럼 flatMapConcat의 변환 연산자에 delay를 줄 경우 변환 처리 과정에서 10초이상 걸리게 된다. 만약 1초에 수십개의 데이터가 flow를 통해 들어올 경우 변환된 데이터의 발행 시점과 변환되기 전 데이터의 발행 시점 사이에 많은 차이가 생길 수 있다.

```kotlin
flow.flatMapConcat{intValue ->
	flow{
		emit(intValue +1)
		delay(1000)
		emit(intValue+2)
		emit(intValue+3)
	}
}.collect{
	println("printed value >> $it")
}

```

즉, 변환을 하는데 시간이 오래 소모될 경우 아래 그림3과 같이 변환이 완료된 새로운 데이터 파이프라인의 발행 시점이 점점 밀리게 된다. 즉, 첫 데이터 파이프라인의 데이터 발행 시점과 소비자(Consumer)의 데이터 소비 시점 사이에 많은 차이가 생기게 될 수 있다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FegVEwJ%2FbtroXNpUf2X%2F0xafnkGQA9Mwmx7zq9IsM0%2Fimg.png)




## 6.3 flatMapLatest란?
flatMapLatest는 flow를 최신 데이터만을 이요해 새로운 flow로 변환할 수 있도록 도와주는 함수이다. flatMapLatest를 사용하면 flow에서 발행된 데이터를 변환하는 도중 새로운 데이터가 들어올 경우 이전 데이터 처리를 취소하고 새로운 데이터를 이요해 데이터를 처리하는데 flatMapLatest는 collectLatest와 동작이 매우 유사하다.

### flatMapLatest 동작 살펴보기
예를 들어 다음과 같은 flow가 있다고 해보자. 이 flow는 1과 5를 순차적으로 발행한다.
```kotlin
val flow = flow<Int>{
	emit(1)
	emit(5)
}
```

위 flow에서 발행되는 데이터 값을 기존 값에 +1, +2, +3을 수행하는 새로운 flow로 변환하려고 한다. 즉 1의경우 2,3,4를 발행하는 새로운 flow로 변환되면 5는 6,7,8에 해당하는 flow로 변환된다. 이러한 flatMapLatest 를 이용해 수행하기 위해서는 다음과 같이 코드를 만들면 된다.

```kotlin
fun collectWithFlatmapConcat(){
	viewModelScope.launch{
		flow.flatMapLatest{iniValue->
			flow{
				emit(intValue+1)
				emit(intValue+2)
				emit(intValue+3)	
			}
		}.collect{
			println("printed value >> $it")
		}
	}
}
```

위 코드를 수행하면 다음과 같이 결과값이 나온다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcZDadm%2Fbtro7fMcKr4%2FtDKXdxHHZL1VO0lX3RJL00%2Fimg.png)

```kotlin
fun collectWithFlatMapConcat(){
	viewModelScope.launch{
		flow.{
			emit(intValue+1)
			delay(1000)
			emit(intValue+2)
			emit(intValue+3)
		}
	}.collect{
		println("printed value >> $it")
	}
}
```

flatMapLatest는 이전 데이터가 변환되기 전에 새로운 데이터가 들어오면 이전 데이터에 대한 변환이 취소되므로, 위와 같이 변환 로직에 delay를 주면 첫번째 데이터(1)에 대한 +1은 처리될 테지만, +2가 처리되기 전에 두번째 데이터(5)가 발행된다.

즉 첫 데이터(1)에서는 2만 생성되고, 3,4가 생성되기 전 변환 로직이 취소된다. 따라서 다음과 같은 결과가 나오게 된다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FxOSYy%2FbtroYj9QuMW%2FWnGxggT7BkrcON2TVXU4W0%2Fimg.png)

## 6.4 flatMapMerge
flatMapConcat과 flatMapLatest는 flow에서 발행된 데이터를 변환할 때 발행된 순서대로 순차적으로 변환한다. 반대로 flatMapMerge는 변환을 병렬로 수행한다.

대부분의 연산이 flatMapConcat이나 flatMapLatest를 이용한 순차 처리에 해당하지만 들어오는 데이터들을 동시에 수집한 후 수집한 값들이 가능한 빨리 방출 될 수 있도록 병렬로 처리되어야 할 때가 있다. 예를 들어 비용 처리를 위해 수십개의 지출 데이터를 취합하여 합치는 작업을 할 경우 굳이 순차적으로 처리하지 않고 병렬로 처리되는 것이 빠를 것이다. flatMapMerge는 이러한 병렬 연산을 지원하기 위해 만들어진 연산자이다.

### flatMapConcat과 flatMapMerge의 차이
아래와 같이 1과 5를 발행하는 flow에 대해 +1, +2, +3 변환을 수행하면서 flatMapConcat을 사용해보자. 그러면 1에 대한  변환값인 2, 3, 4 와 5에 대한 변환 값인 6, 7, 8이 순서대로 나온다.

==flow.map()과의 차이점은 무엇인가??==

```kotlin
fun collectWithFlatMapConcat() {  
    val flow = flow<Int> { 
	    emit(1) 
	    emit (5) 
	} 
	viewModelScope . launch {  
        flow.flatMapConcat { intValue ->  
            flow {  
                emit(intValue + 1) 
                delay (1000) 
                emit (intValue + 2) 
                emit (intValue + 3)  
            }  
        }.collect { println("printed value >> $it") }  
    }}
```

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fee9WDL%2FbtroZFFcsZf%2FTZwrO60IFVYRSPtzDwT8H0%2Fimg.png)

 위의 코드와 같이 변환 연산자 중간에 delay가 있다면 연산이 순차적으로 처리되는데는 시간이 오래 걸릴 것이다. 만약 순차적으로 처리되지 않아도되는 데이터라면 데이터들을 동시에 수집한 후 수집한 값들이 가능한 빨리 방출 될 수 있도록 병렬로 처리 하는 것이 효율적일 것이다. flatMapMerge는 이러한 병렬 연산을 지원하기 위해 만들어진 연산자이다.

위의 flatMapConcat을 flatMapMerge로 바꾸어 어떻게 결과가 나오는지 보도록 하자.

```kotlin
fun collectWithFlatMapMerge() {  
    val flow = flow<Int> {  
        emit(1)  
        emit(5)  
    }  
  
    viewModelScope.launch {  
        flow.flatMapMerge { intValue ->  
            flow {  
                emit(intValue + 1)  
                delay(1000)  
                emit(intValue + 2)  
                emit(intValue + 3)  
            }  
        }.collect {  
            println("printed value >> $it")  
        }  
    }}
```


flatMapMerge를 사용하면 둘째 발행값인 5는 첫째 발행값인 1에 대한 변환이 완료되는 것을 기다리지 않고 변환을 시작한다. 따라서 다음의 순서로 변환이 처리된다.

1. 1이 발행되어 변환된 2가 발행된 후 1에 대한 변환은 1초간 쉰다.

2. 5가 발행되어 변환된 6이 발행되며, 5에 대한 변환은 1초간 쉰다.

3. 그 사이 1은 1초를 모두 쉬고 3과 4를 마저 발행한다.

4. 그 후 5는 1초를 모두 쉬고 7과 8을 발행한다.

### flatMapMerge의 의의
순차 처리는 리소스를 최대한 활용하기가 어려워 시간이 오래 걸린다. 특히 요즘과 같이 멀티코어 환경이 보편화된 시대에는 순차 처리가 필요하지 않는 곳에서 벼렬 처리를 하면 수배에서 수십배까지 연산 속도가 빨라질 수있다.